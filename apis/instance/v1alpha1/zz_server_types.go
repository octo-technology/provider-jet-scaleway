/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PrivateNetworkObservation struct {
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type PrivateNetworkParameters struct {

	// The Private Network ID
	// +kubebuilder:validation:Required
	PnID *string `json:"pnId" tf:"pn_id,omitempty"`

	// The zone you want to attach the resource to
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type RootVolumeObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type RootVolumeParameters struct {

	// Set the volume where the boot the server
	// +kubebuilder:validation:Optional
	Boot *bool `json:"boot,omitempty" tf:"boot,omitempty"`

	// Force deletion of the root volume on instance termination
	// +kubebuilder:validation:Optional
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty" tf:"delete_on_termination,omitempty"`

	// Size of the root volume in gigabytes
	// +kubebuilder:validation:Optional
	SizeInGb *float64 `json:"sizeInGb,omitempty" tf:"size_in_gb,omitempty"`

	// Volume ID of the root volume
	// +kubebuilder:validation:Optional
	VolumeID *string `json:"volumeId,omitempty" tf:"volume_id,omitempty"`

	// Volume type of the root volume
	// +kubebuilder:validation:Optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ServerObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IPv6Address *string `json:"ipv6Address,omitempty" tf:"ipv6_address,omitempty"`

	IPv6Gateway *string `json:"ipv6Gateway,omitempty" tf:"ipv6_gateway,omitempty"`

	IPv6PrefixLength *float64 `json:"ipv6PrefixLength,omitempty" tf:"ipv6_prefix_length,omitempty"`

	OrganizationID *string `json:"organizationId,omitempty" tf:"organization_id,omitempty"`

	PlacementGroupPolicyRespected *bool `json:"placementGroupPolicyRespected,omitempty" tf:"placement_group_policy_respected,omitempty"`

	PrivateIP *string `json:"privateIp,omitempty" tf:"private_ip,omitempty"`

	PublicIP *string `json:"publicIp,omitempty" tf:"public_ip,omitempty"`
}

type ServerParameters struct {

	// The additional volumes attached to the server
	// +kubebuilder:validation:Optional
	AdditionalVolumeIds []*string `json:"additionalVolumeIds,omitempty" tf:"additional_volume_ids,omitempty"`

	// The boot type of the server
	// +kubebuilder:validation:Optional
	BootType *string `json:"bootType,omitempty" tf:"boot_type,omitempty"`

	// ID of the target bootscript (set boot_type to bootscript)
	// +kubebuilder:validation:Optional
	BootscriptID *string `json:"bootscriptId,omitempty" tf:"bootscript_id,omitempty"`

	// The cloud init script associated with this server
	// +kubebuilder:validation:Optional
	CloudInit *string `json:"cloudInit,omitempty" tf:"cloud_init,omitempty"`

	// Enable dynamic IP on the server
	// +kubebuilder:validation:Optional
	EnableDynamicIP *bool `json:"enableDynamicIp,omitempty" tf:"enable_dynamic_ip,omitempty"`

	// Determines if IPv6 is enabled for the server
	// +kubebuilder:validation:Optional
	EnableIPv6 *bool `json:"enableIpv6,omitempty" tf:"enable_ipv6,omitempty"`

	// The ID of the reserved IP for the server
	// +kubebuilder:validation:Optional
	IPID *string `json:"ipId,omitempty" tf:"ip_id,omitempty"`

	// The UUID or the label of the base image used by the server
	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// The placement group the server is attached to
	// +kubebuilder:validation:Optional
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`

	// List of private network to connect with your instance
	// +kubebuilder:validation:Optional
	PrivateNetwork []PrivateNetworkParameters `json:"privateNetwork,omitempty" tf:"private_network,omitempty"`

	// The project_id you want to attach the resource to
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// Root volume attached to the server on creation
	// +kubebuilder:validation:Optional
	RootVolume []RootVolumeParameters `json:"rootVolume,omitempty" tf:"root_volume,omitempty"`

	// The security group the server is attached to
	// +kubebuilder:validation:Optional
	SecurityGroupID *string `json:"securityGroupId,omitempty" tf:"security_group_id,omitempty"`

	// The state of the server should be: started, stopped, standby
	// +kubebuilder:validation:Optional
	State *string `json:"state,omitempty" tf:"state,omitempty"`

	// The tags associated with the server
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The instance type of the server
	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`

	// The user data associated with the server
	// +kubebuilder:validation:Optional
	UserData map[string]*string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The zone you want to attach the resource to
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

// ServerSpec defines the desired state of Server
type ServerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServerParameters `json:"forProvider"`
}

// ServerStatus defines the observed state of Server.
type ServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Server is the Schema for the Servers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,scalewayjet}
type Server struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServerSpec   `json:"spec"`
	Status            ServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServerList contains a list of Servers
type ServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Server `json:"items"`
}

// Repository type metadata.
var (
	Server_Kind             = "Server"
	Server_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Server_Kind}.String()
	Server_KindAPIVersion   = Server_Kind + "." + CRDGroupVersion.String()
	Server_GroupVersionKind = CRDGroupVersion.WithKind(Server_Kind)
)

func init() {
	SchemeBuilder.Register(&Server{}, &ServerList{})
}
